%require "3.2"
%language "c++"
%locations

%code top {
#include <memory>
#include <iostream>
#include <string>
#include <vector>

extern std::vector<std::string> svalstack;
}

%code requires {
#include "report.hpp"
#include "ast.hpp"

namespace yy {
    class Lexer;  /* Generated by reflex with namespace=yy lexer=Lexer */
}
}

%union {
    std::string* str;
    ast::ASTNode* node;
    ast::NodeList* nlist;
}

%parse-param { yy::Lexer& lexer }  /* Construct parser object with lexer */
%parse-param { ast::ASTNode** root }  /* To pass AST root back to driver */

%code{
#include "scanner.hpp"
#undef yylex
#define yylex lexer.yylex  /* Within bison's parse() we should invoke lexer.yylex(), not the global yylex() */

std::vector<std::string> svalstack;
}

%token TOKEN_IDEN
%token TOKEN_NUM_DEC
%token TOKEN_NUM_HEX
%token TOKEN_NUM_OCT
%token TOKEN_NUM_BIN
%token TOKEN_STRING
%token TOKEN_RAWSTRING
%token TOKEN_CHAR

%token TOKEN_DSTAR
%token TOKEN_PLUS_EQUAL
%token TOKEN_MINUS_EQUAL
%token TOKEN_STAR_EQUAL
%token TOKEN_SLASH_EQUAL
%token TOKEN_PERCENT_EQUAL
%token TOKEN_DSTAR_EQUAL
%token TOKEN_DLANGLEBRACKET
%token TOKEN_DRANGLEBRACKET
%token TOKEN_PIPE_EQUAL
%token TOKEN_AMPERSAND_EQUAL
%token TOKEN_TILDE_EQUAL
%token TOKEN_HAT_EQUAL
%token TOKEN_DLAB_EQUAL
%token TOKEN_DRAB_EQUAL
%token TOKEN_DEQUAL
%token TOKEN_TEQUAL
%token TOKEN_EMARK_DEQUAL
%token TOKEN_EMARK_EQUAL
%token TOKEN_LAB_EQUAL
%token TOKEN_RAB_EQUAL
%token TOKEN_DPIPE
%token TOKEN_DAMPERSAND

%token TOKEN_IMPORT

%token TOKEN_CLASS
%token TOKEN_STRUCT
%token TOKEN_ENUM
%token TOKEN_PROTOCOL
%token TOKEN_EXTENSION
%token TOKEN_IF
%token TOKEN_ELSE
%token TOKEN_WHILE
%token TOKEN_FOR
%token TOKEN_IN
%token TOKEN_WHERE
%token TOKEN_SWITCH
%token TOKEN_CASE
%token TOKEN_DEFAULT
%token TOKEN_RETURN
%token TOKEN_BREAK
%token TOKEN_CONTINUE

%type<node> external_expressions external_statements declaration class_declaration function_declaration expression
%type<nlist> translation_unit package_name compound_declaration declaration_list

%start program
%%
program: translation_unit           { *root = $1; };

translation_unit
    : external_expressions                       { $$ = new ast::NodeList(); $$->add($1); }
    | translation_unit external_expressions      { $$->add($2); }
    ;

external_expressions
    : declaration             { $$ = $1; }
    | external_statements     { $$ = $1; }
    | expression              { $$ = new ast::DummyNode("exression"); } // tmp            
    ;


///////////////////////////////////////////////////////////////////////////////
// Source Configuration
///////////////////////////////////////////////////////////////////////////////

external_statements
    : TOKEN_IMPORT package_name ';'  { $$ = new ast::Import($2); }
    ;

package_name
    : TOKEN_IDEN                     { $$ = new ast::NodeList(); $$->add(new ast::Identifier(svalstack.back())); svalstack.pop_back(); }
    | package_name '.' TOKEN_IDEN    { $$->add(new ast::Identifier(svalstack.back())); svalstack.pop_back(); }
    ;


///////////////////////////////////////////////////////////////////////////////
// Declaration
///////////////////////////////////////////////////////////////////////////////

declaration
    : class_declaration     { $$ = $1; }
    | struct_declaration    { $$ = new ast::DummyNode("struct_declaration"); }
    | enum_declaration      { $$ = new ast::DummyNode("enum_declaration"); }
    | protocol_declaration  { $$ = new ast::DummyNode("protocol_declaration"); }
    | function_declaration  { $$ = $1; }
    | variable_declaration  { $$ = new ast::DummyNode("variable_declaration"); }
    ;

class_declaration
    : TOKEN_CLASS TOKEN_IDEN compound_declaration                { $$ = new ast::ClassDecl(svalstack.back(), nullptr, $3); svalstack.pop_back(); }
    | TOKEN_CLASS TOKEN_IDEN ':' TOKEN_IDEN compound_declaration { $$ = new ast::ClassDecl(svalstack.back(), new ast::Identifier(svalstack.back()), $5); svalstack.pop_back(); svalstack.pop_back(); }
    ;

struct_declaration
    : TOKEN_STRUCT TOKEN_IDEN compound_declaration
    | TOKEN_STRUCT TOKEN_IDEN ':' TOKEN_IDEN compound_declaration
    ;

enum_declaration
    : TOKEN_ENUM TOKEN_IDEN compound_declaration
    | TOKEN_ENUM TOKEN_IDEN ':' TOKEN_IDEN compound_declaration
    ;

protocol_declaration
    : TOKEN_PROTOCOL TOKEN_IDEN compound_declaration
    | TOKEN_PROTOCOL TOKEN_IDEN ':' TOKEN_IDEN compound_declaration
    ;

function_declaration
    : TOKEN_IDEN TOKEN_IDEN '(' ')' ';'                                     { $$ = new ast::DummyNode("Func decl -args -body"); }
    | TOKEN_IDEN TOKEN_IDEN '(' parameter_declaration_list ')' ';'          { $$ = new ast::DummyNode("Func decl +args -body"); }
    | TOKEN_IDEN TOKEN_IDEN '(' ')' statement                               { $$ = new ast::FuncDecl(svalstack.back(), new ast::NodeList("args"), new ast::NodeList("body")); svalstack.pop_back(); }
    | TOKEN_IDEN TOKEN_IDEN '(' parameter_declaration_list ')' statement    { $$ = new ast::FuncDecl(svalstack.back(), new ast::NodeList("args"), new ast::NodeList("body")); svalstack.pop_back(); }
    ;

parameter_declaration_list
    : TOKEN_IDEN ':' TOKEN_IDEN                                 // { std::cout << "parameter_declaration_list: " << svalstack.back(); svalstack.pop_back();
                                                                //   std::cout << ", " << svalstack.back() << std::endl; svalstack.pop_back(); }
    | TOKEN_IDEN ':' TOKEN_IDEN ',' parameter_declaration_list  // { std::cout << "parameter_declaration_list: " << svalstack.back(); svalstack.pop_back();
                                                                //   std::cout << ", " << svalstack.back() << std::endl; svalstack.pop_back(); }
    ;

variable_declaration
    : TOKEN_IDEN ':' TOKEN_IDEN ';'
    | TOKEN_IDEN ':' TOKEN_IDEN '=' expression ';'
    ;

compound_declaration
    : '{' '}'                  { $$ = new ast::NodeList(); }
    | '{' declaration_list '}' { $$ = $2; }
    ;

declaration_list
    : declaration                   { $$ = new ast::NodeList(); $$->add($1); }   
    | declaration_list declaration  { $$->add($2); }
    ;


///////////////////////////////////////////////////////////////////////////////
// Expressions
///////////////////////////////////////////////////////////////////////////////

expression
    : TOKEN_NUM_DEC {
        $$ = new ast::Literal(svalstack.back(), "int");
        // std::cout << "expression: " << $$->str() << std::endl;
        svalstack.pop_back();
    }
    | TOKEN_NUM_HEX { $$ = new ast::Literal(svalstack.back(), "int"); svalstack.pop_back(); }
    | TOKEN_NUM_OCT { $$ = new ast::Literal(svalstack.back(), "int"); svalstack.pop_back(); }
    | TOKEN_NUM_BIN { $$ = new ast::Literal(svalstack.back(), "int"); svalstack.pop_back(); }
    | TOKEN_STRING   { $$ = new ast::Literal(svalstack.back(), "string"); svalstack.pop_back(); }
    | TOKEN_RAWSTRING { $$ = new ast::Literal(svalstack.back(), "string"); svalstack.pop_back(); }
    | TOKEN_CHAR        { $$ = new ast::Literal(svalstack.back(), "char"); svalstack.pop_back(); }
    | '(' expression ')' { $$ = new ast::Literal("", ""); }
    | prefix_expression { $$ = new ast::Literal("", ""); }
    | postfix_expression { $$ = new ast::Literal("", ""); }
//    | unary_expression
    | binary_expression { $$ = new ast::Literal("", ""); }
    | ternary_expression { $$ = new ast::Literal("", ""); }
    | identifier_expression { $$ = new ast::Literal("", ""); }
    ;

prefix_expression
    : '@'
    ;

postfix_expression
    : expression '[' expression ']'
    | expression '(' ')'
    | expression '(' argument_list ')'   // { std::cout << "postfix_expression: " << svalstack.back() << std::endl; svalstack.pop_back(); }
    | TOKEN_IDEN '.' expression          // { std::cout << "postfix_expression: " << svalstack.back() << std::endl; svalstack.pop_back(); }

argument_list
    : keyvaluepair
    | keyvaluepair ',' argument_list
    ;

keyvaluepair
    : TOKEN_IDEN ':' expression           // { std::cout << svalstack.back(); svalstack.pop_back(); std::cout << " > " << svalstack.back() << std::endl; svalstack.pop_back();}
    ;

 /*   
unary_expression
    :
    ;
    */

binary_expression
    : arithmetic_expression
    | bitwise_expression
    | logical_expression
    | relational_expression
    | equality_expression
    | assignment_expression
    ;

ternary_expression
    : expression '?' expression ':' expression
    ;

identifier_expression
    : TOKEN_IDEN           // { std::cout << "identifier_expression: " << svalstack[0] << std::endl; }
    | TOKEN_IDEN '?'
    | TOKEN_IDEN '!'
    | TOKEN_IDEN '[' ']'
    ;

arithmetic_expression
    : expression arithmetic_operator expression
    ;

arithmetic_operator: '+' | '-' | '*' | '/' | '%' | TOKEN_DSTAR;

bitwise_expression
    : expression bitwise_operator expression
    ;

bitwise_operator: TOKEN_DLANGLEBRACKET | TOKEN_DRANGLEBRACKET | '|' | '&' | '~' | '^';

logical_expression
    : expression logical_operator expression
    ;

logical_operator: TOKEN_DAMPERSAND | TOKEN_DPIPE;

relational_expression
    : expression relational_opeator expression
    ;

relational_opeator: '<' | '>' | TOKEN_LAB_EQUAL | TOKEN_RAB_EQUAL;

equality_expression
    : expression equality_operator expression
    ;

equality_operator: TOKEN_DEQUAL | TOKEN_EMARK_EQUAL;

assignment_expression
    : identifier_expression '=' expression
    | '(' expression_list ')' '=' expression
    ;

expression_list
    : expression
    | expression ','
    | expression ',' expression_list
    ;


///////////////////////////////////////////////////////////////////////////////
// Statements
///////////////////////////////////////////////////////////////////////////////

statement
    : expression_statement
    | variable_declaration_statement
    | if_statement
    | while_statement
    | for_statement
    | switch_statement
    | jump_statement
    | compound_statement
    ;

expression_statement
    : expression ';'
    ;

variable_declaration_statement
    : TOKEN_IDEN TOKEN_IDEN ';'
    | TOKEN_IDEN TOKEN_IDEN '=' expression ';'
    ;

if_statement
    : TOKEN_IF '(' expression ')' statement
    | TOKEN_IF '(' expression ')' statement TOKEN_ELSE statement
    ;

while_statement
    : TOKEN_WHILE '(' expression ')' statement
    ;

for_statement
    : TOKEN_FOR '(' expression_statement expression_statement expression ')' statement
    | TOKEN_FOR '(' TOKEN_IDEN TOKEN_IN expression ')' statement
    | TOKEN_FOR '(' TOKEN_IDEN TOKEN_IN expression ')' TOKEN_WHERE '(' expression ')' statement
    ;

switch_statement
    : TOKEN_SWITCH '(' expression ')' '{' '}'
    | TOKEN_SWITCH '(' expression ')' statement
    | TOKEN_CASE expression statement
    | TOKEN_DEFAULT statement
    ;

jump_statement
    : TOKEN_RETURN ';'
    | TOKEN_RETURN expression ';' 
    | TOKEN_BREAK ';'
    | TOKEN_CONTINUE ';'
    ;

compound_statement
    : '{' '}'
    | '{' closure_item_list '}'
    ;

closure_item_list
    : closure_item
    | closure_item closure_item_list
    ;

closure_item
    : variable_declaration
    | statement
    ;
%%

void yy::parser::error(yy::location const& loc, std::string const& str) {
    report::error(loc, str);
}